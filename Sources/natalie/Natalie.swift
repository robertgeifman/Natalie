//
//  Natalie.swift
//  Natalie
//
//  Created by Marcin Krzyzanowski on 07/08/16.
//  Copyright Â© 2016 Marcin Krzyzanowski. All rights reserved.
//

import Foundation

struct Natalie {

	struct Header: CustomStringConvertible {
		var description: String {
			var output = String()
			output += "//\n"
			output += "// Autogenerated by Natalie - Storyboard Generator\n"
			output += "// by Marcin Krzyzanowski http://krzyzanowskim.com\n"
			output += "//\n"
			return output
		}
	}

	let storyboards: [StoryboardFile]
	let header = Header()

	var storyboardCustomModules: Set<String> {
		return Set(storyboards.lazy.flatMap { $0.storyboard.customModules })
	}

	init(storyboards: [StoryboardFile]) {
		self.storyboards = storyboards
		assert(Set(storyboards.map { $0.storyboard.os }).count < 2)
	}

	static func process(storyboards: [StoryboardFile]) -> String {
		var output = String()
		for os in OS.allValues {
			let storyboardsForOS = storyboards.filter { $0.storyboard.os == os }
			if !storyboardsForOS.isEmpty {

				if storyboardsForOS.count != storyboards.count {
					output += "#if os(\(os.rawValue))\n"
				}

				output += Natalie(storyboards: storyboardsForOS).process(os: os)

				if storyboardsForOS.count != storyboards.count {
					output += "#endif\n"
				}
			}
		}
		return output
	}

	func process(os: OS) -> String {
		var output = ""

		output += header.description
		output += "import \(os.framework)\n"
		for module in storyboardCustomModules {
			output += "import \(module)\n"
		}
		output += "\n"
		output += "// MARK: - Storyboards\n"

		output += "extension \(os.storyboardType) {\n"
		for (signatureType, returnType) in os.storyboardInstantiationInfo {
			output += "\tfunc instantiateViewController<T: \(returnType)>(ofType type: T.Type) -> T? where T: IdentifiableProtocol {\n"
			output += "\t\tlet instance = type.init()\n"
			output += "\t\tif let identifier = instance.storyboardIdentifier {\n"
			output += "\t\t\treturn self.instantiate\(signatureType)(withIdentifier: identifier) as? T\n"
			output += "\t\t}\n"
			output += "\t\treturn nil\n"
			output += "\t}\n"
			output += "\n"
		}
		output += "}\n"

		output += "\n"
		output += "protocol Storyboard {\n"
		output += "\tstatic var storyboard: \(os.storyboardType) { get }\n"
		output += "\tstatic var identifier: \(os.storyboardIdentifierType) { get }\n"
		output += "}\n"
		output += "\n"

		output += "extension Storyboard {\n"
		output += "\t\tstatic var storyboard: \(os.storyboardType) {\n"
		output += "\t\t\treturn \(os.storyboardType)(name: self.identifier, bundle: nil)\n"
		output += "\t\t}\n"
		for (signatureType, returnType) in os.storyboardInstantiationInfo {
			let cast = (returnType == os.storyboardControllerReturnType ? "" : " as! \(returnType)")
			output += "\n"
			output += "\t\tstatic func instantiate\(signatureType)(withIdentifier identifier: \(os.storyboardSceneIdentifierType)) -> \(returnType) {\n"
			output += "\t\t\treturn self.storyboard.instantiate\(signatureType)(withIdentifier: identifier)\(cast)\n"
			output += "\t\t}\n"

			output += "\n"
			output += "\t\tstatic func instantiateViewController<T: \(returnType)>(ofType type: T.Type) -> T? where T: IdentifiableProtocol {\n"
			output += "\t\t\treturn self.storyboard.instantiateViewController(ofType: type)\n"
			output += "\t\t}\n"
		}

		output += "struct Storyboards {\n"
		for file in storyboards {
			output += file.storyboard.processStoryboard(storyboardName: file.storyboardName, os: os)
		}
		output += "}\n"
		output += "\n"

		let colors = storyboards
			.flatMap { $0.storyboard.colors }
			.filter { $0.catalog != .system }
			.compactMap { $0.assetName }
		if !colors.isEmpty {
			output += "// MARK: - Colors\n"
			output += "@available(\(os.colorOS), *)\n"
			output += "extension \(os.colorType) {\n"
			for colorName in Set(colors) {
				output += "\tstatic let \(swiftRepresentation(for: colorName, firstLetter: .none)) = \(os.colorType)(named: \(initIdentifier(for: os.colorNameType, value: colorName)))\n"
			}
			output += "}\n"
			output += "\n"
		}

		output += "// MARK: - ReusableKind\n"
		output += "enum ReusableKind: String, CustomStringConvertible {\n"
		output += "\tcase tableViewCell = \"tableViewCell\"\n"
		output += "\tcase collectionViewCell = \"collectionViewCell\"\n"
		output += "\n"
		output += "\tvar description: String { return self.rawValue }\n"
		output += "}\n"
		output += "\n"

		output += "// MARK: - SegueKind\n"
		output += "enum SegueKind: String, CustomStringConvertible {\n"
		output += "\tcase relationship = \"relationship\"\n"
		output += "\tcase show = \"show\"\n"
		output += "\tcase presentation = \"presentation\"\n"
		output += "\tcase embed = \"embed\"\n"
		output += "\tcase unwind = \"unwind\"\n"
		output += "\tcase push = \"push\"\n"
		output += "\tcase modal = \"modal\"\n"
		output += "\tcase popover = \"popover\"\n"
		output += "\tcase replace = \"replace\"\n"
		output += "\tcase custom = \"custom\"\n"
		output += "\n"
		output += "\tvar description: String { return self.rawValue }\n"
		output += "}\n"
		output += "\n"
		output += "// MARK: - IdentifiableProtocol\n"
		output += "\n"
		output += "protocol IdentifiableProtocol: Equatable {\n"
		output += "\tvar storyboardIdentifier: \(os.storyboardSceneIdentifierType)? { get }\n"
		output += "}\n"
		output += "\n"
		output += "// MARK: - SegueProtocol\n"
		output += "\n"
		output += "protocol SegueProtocol {\n"
		output += "\tvar identifier: \(os.storyboardSegueIdentifierType)? { get }\n"
		output += "}\n"
		output += "\n"

		output += "func ==<T: SegueProtocol, U: SegueProtocol>(lhs: T, rhs: U) -> Bool {\n"
		output += "\treturn lhs.identifier == rhs.identifier\n"
		output += "}\n"
		output += "\n"
		output += "func ~=<T: SegueProtocol, U: SegueProtocol>(lhs: T, rhs: U) -> Bool {\n"
		output += "\treturn lhs.identifier == rhs.identifier\n"
		output += "}\n"
		output += "\n"
		output += "func ==<T: SegueProtocol>(lhs: T, rhs: \(os.storyboardSegueIdentifierType)) -> Bool {\n"
		output += "\treturn lhs.identifier == rhs\n"
		output += "}\n"
		output += "\n"
		output += "func ~=<T: SegueProtocol>(lhs: T, rhs: \(os.storyboardSegueIdentifierType)) -> Bool {\n"
		output += "\treturn lhs.identifier == rhs\n"
		output += "}\n"
		output += "\n"
		output += "func ==<T: SegueProtocol>(lhs: \(os.storyboardSegueIdentifierType), rhs: T) -> Bool {\n"
		output += "\treturn lhs == rhs.identifier\n"
		output += "}\n"
		output += "\n"
		output += "func ~=<T: SegueProtocol>(lhs: \(os.storyboardSegueIdentifierType), rhs: T) -> Bool {\n"
		output += "\treturn lhs == rhs.identifier\n"
		output += "}\n"
		output += "\n"

#if false
		if os.storyboardSegueIdentifierType != "String" {
			output += "extension \(os.storyboardSegueIdentifierType): ExpressibleByStringLiteral {\n"
			output += "\tpublic typealias StringLiteralType = String\n"
			output += "\tpublic init(stringLiteral value: StringLiteralType) {\n"
			output += "\t\tself.init(rawValue: value)\n"
			output += "\t}\n"
			output += "}\n"
			output += "\n"
			output += "func ==<T: SegueProtocol>(lhs: T, rhs: String) -> Bool {\n"
			output += "\treturn lhs.identifier?.rawValue == rhs\n"
			output += "}\n"
			output += "\n"
			output += "func ~=<T: SegueProtocol>(lhs: T, rhs: String) -> Bool {\n"
			output += "\treturn lhs.identifier?.rawValue == rhs\n"
			output += "}\n"
			output += "\n"
			output += "func ==<T: SegueProtocol>(lhs: String, rhs: T) -> Bool {\n"
			output += "\treturn lhs == rhs.identifier?.rawValue\n"
			output += "}\n"
			output += "\n"
			output += "func ~=<T: SegueProtocol>(lhs: String, rhs: T) -> Bool {\n"
			output += "\treturn lhs == rhs.identifier?.rawValue\n"
			output += "}\n"
			output += "\n"
		}
#endif
		output += "// MARK: - ReusableViewProtocol\n"
		output += "protocol ReusableViewProtocol: IdentifiableProtocol {\n"
		output += "\tvar viewType: \(os.viewType).Type? { get }\n"
		output += "}\n"
		output += "\n"

		output += "func ==<T: ReusableViewProtocol, U: ReusableViewProtocol>(lhs: T, rhs: U) -> Bool {\n"
		output += "\treturn lhs.storyboardIdentifier == rhs.storyboardIdentifier\n"
		output += "}\n"
		output += "\n"

		output += "// MARK: - Protocol Implementation\n"
		output += "extension \(os.storyboardSegueType): SegueProtocol {\n"
		output += "}\n"
		output += "\n"

		if let reusableViews = os.resuableViews {
			for reusableView in reusableViews {
				output += "extension \(reusableView): ReusableViewProtocol {\n"
				output += "\tpublic var viewType: UIView.Type? { return type(of: self) }\n"
				output += "\tpublic var storyboardIdentifier: String? { return self.reuseIdentifier }\n"
				output += "}\n"
				output += "\n"
			}
		}

		for controllerType in os.storyboardControllerTypes {
			output += "// MARK: - \(controllerType) extension\n"
			output += "extension \(controllerType) {\n"
			output += "\tfunc perform<T: SegueProtocol>(segue: T, sender: Any?) {\n"
			output += "\t\tif let identifier = segue.identifier {\n"
			output += "\t\t\tperformSegue(withIdentifier: identifier, sender: sender)\n"
			output += "\t\t}\n"
			output += "\t}\n"
			output += "\n"
			output += "\tfunc perform<T: SegueProtocol>(segue: T) {\n"
			output += "\t\tperform(segue: segue, sender: nil)\n"
			output += "\t}\n"
			output += "}\n"
		}

		if os == OS.iOS {
			output += "// MARK: - UICollectionView\n"
			output += "extension UICollectionView {\n"
			output += "\tfunc dequeue<T: ReusableViewProtocol>(reusable: T, for: IndexPath) -> UICollectionViewCell? {\n"
			output += "\t\tif let identifier = reusable.storyboardIdentifier {\n"
			output += "\t\t\treturn dequeueReusableCell(withReuseIdentifier: identifier, for: `for`)\n"
			output += "\t\t}\n"
			output += "\t\treturn nil\n"
			output += "\t}\n"
			output += "\n"
			output += "\tfunc register<T: ReusableViewProtocol>(reusable: T) {\n"
			output += "\t\tif let type = reusable.viewType, let identifier = reusable.storyboardIdentifier {\n"
			output += "\t\t\tregister(type, forCellWithReuseIdentifier: identifier)\n"
			output += "\t\t}\n"
			output += "\t}\n"
			output += "\n"
			output += "\tfunc dequeueReusableSupplementaryViewOfKind<T: ReusableViewProtocol>(elementKind: String, withReusable reusable: T, for: IndexPath) -> UICollectionReusableView? {\n"
			output += "\t\tif let identifier = reusable.storyboardIdentifier {\n"
			output += "\t\t\treturn dequeueReusableSupplementaryView(ofKind: elementKind, withReuseIdentifier: identifier, for: `for`)\n"
			output += "\t\t}\n"
			output += "\t\treturn nil\n"
			output += "\t}\n"
			output += "\n"
			output += "\tfunc register<T: ReusableViewProtocol>(reusable: T, forSupplementaryViewOfKind elementKind: String) {\n"
			output += "\t\tif let type = reusable.viewType, let identifier = reusable.storyboardIdentifier {\n"
			output += "\t\t\tregister(type, forSupplementaryViewOfKind: elementKind, withReuseIdentifier: identifier)\n"
			output += "\t\t}\n"
			output += "\t}\n"
			output += "}\n"

			output += "// MARK: - UITableView\n"
			output += "extension UITableView {\n"
			output += "\tfunc dequeue<T: ReusableViewProtocol>(reusable: T, for: IndexPath) -> UITableViewCell? {\n"
			output += "\t\tif let identifier = reusable.storyboardIdentifier {\n"
			output += "\t\t\treturn dequeueReusableCell(withIdentifier: identifier, for: `for`)\n"
			output += "\t\t}\n"
			output += "\t\treturn nil\n"
			output += "\t}\n"
			output += "\n"
			output += "\tfunc register<T: ReusableViewProtocol>(reusable: T) {\n"
			output += "\t\tif let type = reusable.viewType, let identifier = reusable.storyboardIdentifier {\n"
			output += "\t\t\tregister(type, forCellReuseIdentifier: identifier)\n"
			output += "\t\t}\n"
			output += "\t}\n"
			output += "\n"
			output += "\tfunc dequeueReusableHeaderFooter<T: ReusableViewProtocol>(_ reusable: T) -> UITableViewHeaderFooterView? {\n"
			output += "\t\tif let identifier = reusable.storyboardIdentifier {\n"
			output += "\t\t\treturn dequeueReusableHeaderFooterView(withIdentifier: identifier)\n"
			output += "\t\t}\n"
			output += "\t\treturn nil\n"
			output += "\t}\n"
			output += "\n"
			output += "\tfunc registerReusableHeaderFooter<T: ReusableViewProtocol>(_ reusable: T) {\n"
			output += "\t\tif let type = reusable.viewType, let identifier = reusable.storyboardIdentifier {\n"
			output += "\t\t\t register(type, forHeaderFooterViewReuseIdentifier: identifier)\n"
			output += "\t\t}\n"
			output += "\t}\n"
			output += "}\n"
		}

		let storyboardModules = storyboardCustomModules
		for file in storyboards {
			output += file.storyboard.processViewControllers(storyboardCustomModules: storyboardModules)
		}

		return output
	}
}
