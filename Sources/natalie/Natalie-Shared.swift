//
// Autogenerated by Natalie - Storyboard Generator
// by Marcin Krzyzanowski http://krzyzanowskim.com
//
import Cocoa

// MARK: - Storyboards
extension NSStoryboard {
	func instantiateViewController<T: NSWindowController>(ofType type: T.Type) -> T? where T: IdentifiableProtocol {
		let instance = type.init()
		if let identifier = instance.storyboardIdentifier {
			return self.instantiateController(withIdentifier: identifier) as? T
		}
		return nil
	}

	func instantiateViewController<T: NSViewController>(ofType type: T.Type) -> T? where T: IdentifiableProtocol {
		let instance = type.init()
		if let identifier = instance.storyboardIdentifier {
			return self.instantiateController(withIdentifier: identifier) as? T
		}
		return nil
	}
}

protocol Storyboard {
	static var storyboard: NSStoryboard { get }
	static var identifier: NSStoryboard.Name { get }
}

extension Storyboard {
	static var storyboard: NSStoryboard {
		return NSStoryboard(name: self.identifier, bundle: nil)
	}

	static func instantiateController(withIdentifier identifier: NSStoryboard.SceneIdentifier) -> NSWindowController {
		return self.storyboard.instantiateController(withIdentifier: identifier) as! NSWindowController
	}

	static func instantiateViewController<T: NSWindowController>(ofType type: T.Type) -> T? where T: IdentifiableProtocol {
		return self.storyboard.instantiateViewController(ofType: type)
	}

	static func instantiateController(withIdentifier identifier: NSStoryboard.SceneIdentifier) -> NSViewController {
		return self.storyboard.instantiateController(withIdentifier: identifier) as! NSViewController
	}

	static func instantiateViewController<T: NSViewController>(ofType type: T.Type) -> T? where T: IdentifiableProtocol {
		return self.storyboard.instantiateViewController(ofType: type)
	}
}

// MARK: - ReusableKind
enum ReusableKind: String, CustomStringConvertible {
	case tableViewCell = "tableViewCell"
	case collectionViewCell = "collectionViewCell"

	var description: String { return self.rawValue }
}

// MARK: - SegueKind
enum SegueKind: String, CustomStringConvertible {
	case relationship = "relationship"
	case show = "show"
	case presentation = "presentation"
	case embed = "embed"
	case unwind = "unwind"
	case push = "push"
	case modal = "modal"
	case popover = "popover"
	case replace = "replace"
	case custom = "custom"

	var description: String { return self.rawValue }
}

// MARK: - IdentifiableProtocol
protocol IdentifiableProtocol: Equatable {
	var storyboardIdentifier: NSStoryboard.SceneIdentifier? { get }
}

// MARK: - SegueProtocol
protocol SegueProtocol {
	var identifier: NSStoryboardSegue.Identifier? { get }
}

func ==<T: SegueProtocol, U: SegueProtocol>(lhs: T, rhs: U) -> Bool {
	return lhs.identifier == rhs.identifier
}

func ~=<T: SegueProtocol, U: SegueProtocol>(lhs: T, rhs: U) -> Bool {
	return lhs.identifier == rhs.identifier
}

func ==<T: SegueProtocol>(lhs: T, rhs: NSStoryboardSegue.Identifier) -> Bool {
	return lhs.identifier == rhs
}

func ~=<T: SegueProtocol>(lhs: T, rhs: NSStoryboardSegue.Identifier) -> Bool {
	return lhs.identifier == rhs
}

func ==<T: SegueProtocol>(lhs: NSStoryboardSegue.Identifier, rhs: T) -> Bool {
	return lhs == rhs.identifier
}

func ~=<T: SegueProtocol>(lhs: NSStoryboardSegue.Identifier, rhs: T) -> Bool {
	return lhs == rhs.identifier
}

// MARK: - ReusableViewProtocol
protocol ReusableViewProtocol: IdentifiableProtocol {
	var viewType: NSView.Type? { get }
}

func ==<T: ReusableViewProtocol, U: ReusableViewProtocol>(lhs: T, rhs: U) -> Bool {
	return lhs.storyboardIdentifier == rhs.storyboardIdentifier
}

// MARK: - Protocol Implementation
extension NSStoryboardSegue: SegueProtocol {
}

// MARK: - NSViewController extension
extension NSViewController {
	func perform<T: SegueProtocol>(segue: T, sender: Any?) {
		if let identifier = segue.identifier {
			performSegue(withIdentifier: identifier, sender: sender)
		}
	}

	func perform<T: SegueProtocol>(segue: T) {
		perform(segue: segue, sender: nil)
	}
}

// MARK: - NSWindowController extension
extension NSWindowController {
	func perform<T: SegueProtocol>(segue: T, sender: Any?) {
		if let identifier = segue.identifier {
			performSegue(withIdentifier: identifier, sender: sender)
		}
	}

	func perform<T: SegueProtocol>(segue: T) {
		perform(segue: segue, sender: nil)
	}
}

#if os(iOS)
// MARK: - UICollectionView
extension UICollectionView {
	func dequeue<T: ReusableViewProtocol>(reusable: T, for: IndexPath) -> UICollectionViewCell? {
		if let identifier = reusable.storyboardIdentifier {
			return dequeueReusableCell(withReuseIdentifier: identifier, for: `for`)
		}
		return nil
	}

	func register<T: ReusableViewProtocol>(reusable: T) {
		if let type = reusable.viewType, let identifier = reusable.storyboardIdentifier {
			register(type, forCellWithReuseIdentifier: identifier)
		}
	}

	func dequeueReusableSupplementaryViewOfKind<T: ReusableViewProtocol>(elementKind: String, withReusable reusable: T, for: IndexPath) -> UICollectionReusableView? {
		if let identifier = reusable.storyboardIdentifier {
			return dequeueReusableSupplementaryView(ofKind: elementKind, withReuseIdentifier: identifier, for: `for`)
		}
		return nil
	}

	func register<T: ReusableViewProtocol>(reusable: T, forSupplementaryViewOfKind elementKind: String) {
		if let type = reusable.viewType, let identifier = reusable.storyboardIdentifier {
			register(type, forSupplementaryViewOfKind: elementKind, withReuseIdentifier: identifier)
		}
	}
}
// MARK: - UITableView
extension UITableView {
	func dequeue<T: ReusableViewProtocol>(reusable: T, for: IndexPath) -> UITableViewCell? {
		if let identifier = reusable.storyboardIdentifier {
			return dequeueReusableCell(withIdentifier: identifier, for: `for`)
		}
		return nil
	}

	func register<T: ReusableViewProtocol>(reusable: T) {
		if let type = reusable.viewType, let identifier = reusable.storyboardIdentifier {
			register(type, forCellReuseIdentifier: identifier)
		}
	}

	func dequeueReusableHeaderFooter<T: ReusableViewProtocol>(_ reusable: T) -> UITableViewHeaderFooterView? {
		if let identifier = reusable.storyboardIdentifier {
			return dequeueReusableHeaderFooterView(withIdentifier: identifier)
		}
		return nil
	}

	func registerReusableHeaderFooter<T: ReusableViewProtocol>(_ reusable: T) {
		if let type = reusable.viewType, let identifier = reusable.storyboardIdentifier {
			 register(type, forHeaderFooterViewReuseIdentifier: identifier)
		}
	}
}
#endif // os(iOS)
